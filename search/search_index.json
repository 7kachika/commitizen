{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Commitizen is a tool designed for teams. Its main purpose is to define a standard way of commiting rules and communicating it (using the cli provided by commitizen). The reasoning behind it is that is easier to read, and enforces writing descriptive commits. Besides that, having a convetion on your commits, makes it possible to parse them and use them for something else, like generating automatically the version or a changelog. Commitizen features Command line utility to create commits with your rules. Defaults: Conventional commits Display information about your commit rules (commands: schema, example, info) Bump version automatically using semantic verisoning based on the commits. Read More Generate a changelog using Keep a changelog (Planned feature) Requirements Python 3.6+ Git 1.8.5.2 + Installation Global installation sudo pip3 install -U Commitizen Python project You can add it to your local project using one of these: pip install -U commitizen poetry add commitizen --dev Usage Commiting Run in your terminal cz commit or the shortcut cz c Help $ cz --help usage: cz [ -h ] [ --debug ] [ -n NAME ] [ --version ] { ls,commit,c,example,info,schema,bump } ... Commitizen is a cli tool to generate conventional commits. For more information about the topic go to https://conventionalcommits.org/ optional arguments: -h, --help show this help message and exit --debug use debug mode -n NAME, --name NAME use the given commitizen --version get the version of the installed commitizen commands: { ls,commit,c,example,info,schema,bump } ls show available commitizens commit ( c ) create new commit example show commit example info show information about the cz schema show commit schema bump bump semantic version based on the git log Contributing Feel free to create a PR. Clone the repo. Add your modifications Create a virtualenv Run ./scripts/test","title":"Introduction"},{"location":"#about","text":"Commitizen is a tool designed for teams. Its main purpose is to define a standard way of commiting rules and communicating it (using the cli provided by commitizen). The reasoning behind it is that is easier to read, and enforces writing descriptive commits. Besides that, having a convetion on your commits, makes it possible to parse them and use them for something else, like generating automatically the version or a changelog.","title":"About"},{"location":"#commitizen-features","text":"Command line utility to create commits with your rules. Defaults: Conventional commits Display information about your commit rules (commands: schema, example, info) Bump version automatically using semantic verisoning based on the commits. Read More Generate a changelog using Keep a changelog (Planned feature)","title":"Commitizen features"},{"location":"#requirements","text":"Python 3.6+ Git 1.8.5.2 +","title":"Requirements"},{"location":"#installation","text":"Global installation sudo pip3 install -U Commitizen","title":"Installation"},{"location":"#python-project","text":"You can add it to your local project using one of these: pip install -U commitizen poetry add commitizen --dev","title":"Python project"},{"location":"#usage","text":"","title":"Usage"},{"location":"#commiting","text":"Run in your terminal cz commit or the shortcut cz c","title":"Commiting"},{"location":"#help","text":"$ cz --help usage: cz [ -h ] [ --debug ] [ -n NAME ] [ --version ] { ls,commit,c,example,info,schema,bump } ... Commitizen is a cli tool to generate conventional commits. For more information about the topic go to https://conventionalcommits.org/ optional arguments: -h, --help show this help message and exit --debug use debug mode -n NAME, --name NAME use the given commitizen --version get the version of the installed commitizen commands: { ls,commit,c,example,info,schema,bump } ls show available commitizens commit ( c ) create new commit example show commit example info show information about the cz schema show commit schema bump bump semantic version based on the git log","title":"Help"},{"location":"#contributing","text":"Feel free to create a PR. Clone the repo. Add your modifications Create a virtualenv Run ./scripts/test","title":"Contributing"},{"location":"bump/","text":"About The version is bumped automatically based on the commits. The commits should follow the rules of the commiter in order to be parsed properly. It is possible to specify a prerelease (alpha, beta, release candidate) version. The version can also be manually bumped. The version format follows semantic versioning . This means MAJOR.MINOR.PATCH Increment Description Conventional commit map MAJOR Breaking changes introduced BREAKING CHANGE MINOR New features feat PATCH Fixes fix + everything else Prereleases are supported following python's PEP 0440 The scheme of this format is [ N! ] N ( .N ) * [{ a | b | rc } N ][ .postN ][ .devN ] Some examples: 0 .9.0 0 .9.1 0 .9.2 0 .9.10 0 .9.11 1 .0.0a0 # alpha 1 .0.0a1 1 .0.0b0 # beta 1 .0.0rc0 # release candidate 1 .0.0rc1 1 .0.0 1 .0.1 1 .1.0 2 .0.0 2 .0.1a post and dev releases are not supported yet. Usage $ cz bump --help usage: cz bump [ -h ] [ --dry-run ] [ --files-only ] [ --yes ] [ --tag-format TAG_FORMAT ] [ --bump-message BUMP_MESSAGE ] [ --prerelease { alpha,beta,rc }] [ --increment { MAJOR,MINOR,PATCH }] optional arguments: -h, --help show this help message and exit --dry-run show output to stdout, no commit, no modified files --files-only bump version in the files from the config --yes accept automatically questions done --tag-format TAG_FORMAT format used to tag the commmit and read it, use it in existing projects, wrap around simple quotes --bump-message BUMP_MESSAGE template used to create the release commmit, useful when working with CI --prerelease { alpha,beta,rc } , -pr { alpha,beta,rc } choose type of prerelease --increment { MAJOR,MINOR,PATCH } manually specify the desired increment Configuration tag_format Used to read the format from the git tags, and also to generate the tags. Supports 2 types of formats, a simple and a more complex. cz bump --tag_format = \"v $version \" cz bump --tag_format = \"v $minor . $major . $path$prerelease \" In your pyproject.toml or .cz.toml [tool.commitizen] tag_format = \"v$minor.$major.$path$prerelease\" Or in your .cz (TO BE DEPRECATED) [commitizen] tag_format = v$minor.$major.$path$prerelease The variables must be preceded by a $ sign. Suppported variables: Variable Description $version full generated version $major MAJOR increment $minor MINOR increment $patch PATCH increment $prerelease Prerelase (alpha, beta, release candidate) files Used to identify the files which should be updated with the new version. It is also possible to provide a pattern for each file, separated by colons ( : ). Commitizen will update it's configuration file automatically ( pyproject.toml , .cz ) when bumping, regarding if the file is present or not in files . Some examples pyproject.toml or .cz.toml [tool.commitizen] files = [ \"src/__version__.py\", \"setup.py:version\" ] .cz (TO BE DEPRECATED) [commitizen] files = [ \"src/__version__.py\", \"setup.py:version\" ] In the example above, we can see the reference \"setup.py:version\" . This means that it will find a file setup.py and will only make a change in a line containing the version substring. bump_message Template used to specify the commit message generated when bumping defaults to: bump: version $current_version \u2192 $new_version Variable Description $current_version the version existing before bumping $new_version version generated after bumping Some examples pyproject.toml or .cz.toml [tool.commitizen] bump_message = \"release $current_version \u2192 $new_version [skip-ci]\" .cz (TO BE DEPRECATED) [commitizen] bump_message = release $current_version \u2192 $new_version [skip-ci] Custom bump Read the customizing section .","title":"Bump"},{"location":"bump/#about","text":"The version is bumped automatically based on the commits. The commits should follow the rules of the commiter in order to be parsed properly. It is possible to specify a prerelease (alpha, beta, release candidate) version. The version can also be manually bumped. The version format follows semantic versioning . This means MAJOR.MINOR.PATCH Increment Description Conventional commit map MAJOR Breaking changes introduced BREAKING CHANGE MINOR New features feat PATCH Fixes fix + everything else Prereleases are supported following python's PEP 0440 The scheme of this format is [ N! ] N ( .N ) * [{ a | b | rc } N ][ .postN ][ .devN ] Some examples: 0 .9.0 0 .9.1 0 .9.2 0 .9.10 0 .9.11 1 .0.0a0 # alpha 1 .0.0a1 1 .0.0b0 # beta 1 .0.0rc0 # release candidate 1 .0.0rc1 1 .0.0 1 .0.1 1 .1.0 2 .0.0 2 .0.1a post and dev releases are not supported yet.","title":"About"},{"location":"bump/#usage","text":"$ cz bump --help usage: cz bump [ -h ] [ --dry-run ] [ --files-only ] [ --yes ] [ --tag-format TAG_FORMAT ] [ --bump-message BUMP_MESSAGE ] [ --prerelease { alpha,beta,rc }] [ --increment { MAJOR,MINOR,PATCH }] optional arguments: -h, --help show this help message and exit --dry-run show output to stdout, no commit, no modified files --files-only bump version in the files from the config --yes accept automatically questions done --tag-format TAG_FORMAT format used to tag the commmit and read it, use it in existing projects, wrap around simple quotes --bump-message BUMP_MESSAGE template used to create the release commmit, useful when working with CI --prerelease { alpha,beta,rc } , -pr { alpha,beta,rc } choose type of prerelease --increment { MAJOR,MINOR,PATCH } manually specify the desired increment","title":"Usage"},{"location":"bump/#configuration","text":"","title":"Configuration"},{"location":"bump/#tag_format","text":"Used to read the format from the git tags, and also to generate the tags. Supports 2 types of formats, a simple and a more complex. cz bump --tag_format = \"v $version \" cz bump --tag_format = \"v $minor . $major . $path$prerelease \" In your pyproject.toml or .cz.toml [tool.commitizen] tag_format = \"v$minor.$major.$path$prerelease\" Or in your .cz (TO BE DEPRECATED) [commitizen] tag_format = v$minor.$major.$path$prerelease The variables must be preceded by a $ sign. Suppported variables: Variable Description $version full generated version $major MAJOR increment $minor MINOR increment $patch PATCH increment $prerelease Prerelase (alpha, beta, release candidate)","title":"tag_format"},{"location":"bump/#files","text":"Used to identify the files which should be updated with the new version. It is also possible to provide a pattern for each file, separated by colons ( : ). Commitizen will update it's configuration file automatically ( pyproject.toml , .cz ) when bumping, regarding if the file is present or not in files . Some examples pyproject.toml or .cz.toml [tool.commitizen] files = [ \"src/__version__.py\", \"setup.py:version\" ] .cz (TO BE DEPRECATED) [commitizen] files = [ \"src/__version__.py\", \"setup.py:version\" ] In the example above, we can see the reference \"setup.py:version\" . This means that it will find a file setup.py and will only make a change in a line containing the version substring.","title":"files"},{"location":"bump/#bump_message","text":"Template used to specify the commit message generated when bumping defaults to: bump: version $current_version \u2192 $new_version Variable Description $current_version the version existing before bumping $new_version version generated after bumping Some examples pyproject.toml or .cz.toml [tool.commitizen] bump_message = \"release $current_version \u2192 $new_version [skip-ci]\" .cz (TO BE DEPRECATED) [commitizen] bump_message = release $current_version \u2192 $new_version [skip-ci]","title":"bump_message"},{"location":"bump/#custom-bump","text":"Read the customizing section .","title":"Custom bump"},{"location":"config/","text":"Configuration Commitizen has support for toml and ini files. pyproject.toml or .cz.toml Add an entry to pyproject.toml or .cz.toml . Recommended for python projects. [tool.commitizen] name = \"cz_conventional_commits\" version = \"0.1.0\" files = [ \"src/__version__.py\", \"pyproject.toml:version\" ] style = [ [\"qmark\", \"fg:#ff9d00 bold\"], [\"question\", \"bold\"], [\"answer\", \"fg:#ff9d00 bold\"], [\"pointer\", \"fg:#ff9d00 bold\"], [\"highlighted\", \"fg:#ff9d00 bold\"], [\"selected\", \"fg:#cc5454\"], [\"separator\", \"fg:#cc5454\"], [\"instruction\", \"\"], [\"text\", \"\"], [\"disabled\", \"fg:#858585 italic\"] ] INI files INI files will not be supported in next major version. Please use toml instead Supported files: .cz , .cz.cfg , setup.py , and $HOME/.cz The format is slightly different to the toml , so pay attention. Recommended for other languages projects (js, go, etc). [commitizen] name = cz_conventional_commits version = 0.1.0 files = [ \"src/__version__.py\", \"pyproject.toml:version\" ] style = [ [\"qmark\", \"fg:#ff9d00 bold\"], [\"question\", \"bold\"], [\"answer\", \"fg:#ff9d00 bold\"], [\"pointer\", \"fg:#ff9d00 bold\"], [\"highlighted\", \"fg:#ff9d00 bold\"], [\"selected\", \"fg:#cc5454\"], [\"separator\", \"fg:#cc5454\"], [\"instruction\", \"\"], [\"text\", \"\"], [\"disabled\", \"fg:#858585 italic\"] ] The extra tab before the square brakets ( ] ) at the end is required. Settings Variable Type Default Description name str \"cz_conventional_commits\" Name of the commiting rules to use version str None Current version. Example: \"0.1.2\" files list [ ] Files were the version will be updated. A pattern to match a line, can also be specified, separated by : See more tag_format str None Format for the git tag, useful for old projects, that use a convention like \"v1.2.1\" . See more bump_message str None Create custom commit message, useful to skip ci. See more style list see above Style for the prompts (It will merge this value with default style.) See More (Styling your prompts with your favorite colors) customize dict None This is only supported when config through toml . Custom rules for committing and bumping. See more","title":"Configuration"},{"location":"config/#configuration","text":"Commitizen has support for toml and ini files.","title":"Configuration"},{"location":"config/#pyprojecttoml-or-cztoml","text":"Add an entry to pyproject.toml or .cz.toml . Recommended for python projects. [tool.commitizen] name = \"cz_conventional_commits\" version = \"0.1.0\" files = [ \"src/__version__.py\", \"pyproject.toml:version\" ] style = [ [\"qmark\", \"fg:#ff9d00 bold\"], [\"question\", \"bold\"], [\"answer\", \"fg:#ff9d00 bold\"], [\"pointer\", \"fg:#ff9d00 bold\"], [\"highlighted\", \"fg:#ff9d00 bold\"], [\"selected\", \"fg:#cc5454\"], [\"separator\", \"fg:#cc5454\"], [\"instruction\", \"\"], [\"text\", \"\"], [\"disabled\", \"fg:#858585 italic\"] ]","title":"pyproject.toml or .cz.toml"},{"location":"config/#ini-files","text":"INI files will not be supported in next major version. Please use toml instead Supported files: .cz , .cz.cfg , setup.py , and $HOME/.cz The format is slightly different to the toml , so pay attention. Recommended for other languages projects (js, go, etc). [commitizen] name = cz_conventional_commits version = 0.1.0 files = [ \"src/__version__.py\", \"pyproject.toml:version\" ] style = [ [\"qmark\", \"fg:#ff9d00 bold\"], [\"question\", \"bold\"], [\"answer\", \"fg:#ff9d00 bold\"], [\"pointer\", \"fg:#ff9d00 bold\"], [\"highlighted\", \"fg:#ff9d00 bold\"], [\"selected\", \"fg:#cc5454\"], [\"separator\", \"fg:#cc5454\"], [\"instruction\", \"\"], [\"text\", \"\"], [\"disabled\", \"fg:#858585 italic\"] ] The extra tab before the square brakets ( ] ) at the end is required.","title":"INI files"},{"location":"config/#settings","text":"Variable Type Default Description name str \"cz_conventional_commits\" Name of the commiting rules to use version str None Current version. Example: \"0.1.2\" files list [ ] Files were the version will be updated. A pattern to match a line, can also be specified, separated by : See more tag_format str None Format for the git tag, useful for old projects, that use a convention like \"v1.2.1\" . See more bump_message str None Create custom commit message, useful to skip ci. See more style list see above Style for the prompts (It will merge this value with default style.) See More (Styling your prompts with your favorite colors) customize dict None This is only supported when config through toml . Custom rules for committing and bumping. See more","title":"Settings"},{"location":"customization/","text":"Customizing commitizen is not hard at all. Customize through customize class The basic steps are: Inheriting from BaseCommitizen Give a name to your rules. expose the class at the end of your file assigning it to discover_this Create a python package starting with cz_ using setup.py , poetry , etc Check an example on how to configure BaseCommitizen . Custom commit rules Create a file starting with cz_ for example cz_jira.py . This prefix is used to detect the plugin. Same method flask uses Inherit from BaseCommitizen and you must define questions and message . The others are optionals. from commitizen.cz.base import BaseCommitizen class JiraCz ( BaseCommitizen ): def questions ( self ) -> list : \"\"\"Questions regarding the commit message.\"\"\" questions = [ { 'type' : 'input' , 'name' : 'title' , 'message' : 'Commit title' }, { 'type' : 'input' , 'name' : 'issue' , 'message' : 'Jira Issue number:' }, ] return questions def message ( self , answers : dict ) -> str : \"\"\"Generate the message with the given answers.\"\"\" return '{0} (#{1})' . format ( answers [ 'title' ], answers [ 'issue' ]) def example ( self ) -> str : \"\"\"Provide an example to help understand the style (OPTIONAL) Used by `cz example`. \"\"\" return 'Problem with user (#321)' def schema ( self ) -> str : \"\"\"Show the schema used (OPTIONAL) Used by `cz schema`. \"\"\" return '<title> (<issue>)' def info ( self ) -> str : \"\"\"Explanation of the commit rules. (OPTIONAL) Used by `cz info`. \"\"\" return 'We use this because is useful' discover_this = JiraCz # used by the plugin system The next file required is setup.py modified from flask version from setuptools import setup setup ( name = 'JiraCommitizen' , version = '0.1.0' , py_modules = [ 'cz_jira' ], license = 'MIT' , long_description = 'this is a long description' , install_requires = [ 'commitizen' ] ) So at the end we would have . \u251c\u2500\u2500 cz_jira.py \u2514\u2500\u2500 setup.py And that's it, you can install it without uploading to pypi by simply doing pip install . If you feel like it should be part of this repo, create a PR. Custom bump rules You need to define 2 parameters inside BaseCommitizen . Parameter Type Default Description bump_pattern str None Regex to extract information from commit (subject and body) bump_map dict None Dictionary mapping the extracted information to a SemVer increment type ( MAJOR , MINOR , PATCH ) Let's see an exampple from commitizen.cz.base import BaseCommitizen class StrangeCommitizen ( BaseCommitizen ): bump_pattern = r \"^(break|new|fix|hotfix)\" bump_map = { \"break\" : \"MAJOR\" , \"new\" : \"MINOR\" , \"fix\" : \"PATCH\" , \"hotfix\" : \"PATCH\" } That's it, your commitizen now supports custom rules and you can run cz -n cz_strange bump Raise Customize Exception If you wannt commitizen to catch your exception and print the message, you'll have to inherit CzException . from commitizen.cz.exception import CzException class NoSubjectProvidedException ( CzException ): ... Customize in toml This is only supported when configuring through toml (e.g., pyproject.toml , .cz , and .cz.toml ) The basic steps are: 1. Define your custom committing or bumpping rules in the configuration file. 2. Declare name = \"cz_customize\" in your configuration file, or add -n cz_customize when running commitizen. Example: [tool.commitizen] name = \"cz_customize\" [tool.commitizen.customize] message_template = \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" example = \"feature: this feature eanable customize through config file\" schema = \"<type>: <body>\" bump_pattern = \"^(break|new|fix|hotfix)\" bump_map = {\"break\" = \"MAJOR\", \"new\" = \"MINOR\", \"fix\" = \"PATCH\", \"hotfix\" = \"PATCH\"} info_path = \"cz_customize_info.txt\" info = \"\"\" This is customized info \"\"\" [[tool.commitizen.customize.questions]] type = \"list\" name = \"change_type\" choices = [\"feature\", \"bug fix\"] message = \"Select the type of change you are committing\" [[tool.commitizen.customize.questions]] type = \"input\" name = \"message\" message = \"Body.\" [[tool.commitizen.customize.questions]] type = \"confirm\" name = \"show_message\" message = \"Do you want to add body message in commit?\" Customize configuration Parameter Type Default Description question dict None Questions regarding the commit message. Detatiled below. message_template str None The template for generating message from the given answers. message_template should either follow the string.Template or Jinja2 formatting specification, and all the variables in this template should be defined in name in questions . Note that Jinja2 is not installed by default. If not installed, commitizen will use string.Template formatting. example str None (OPTIONAL) Provide an example to help understand the style. Used by cz example . schema str None (OPTIONAL) Show the schema used. Used by cz schema . info_path str None (OPTIONAL) The path to the file that contains explanation of the commit rules. Used by cz info . If not provided cz info , will load info instead. info str None (OPTIONAL) Explanation of the commit rules. Used by cz info . bump_map dict None (OPTIONAL) Dictionary mapping the extracted information to a SemVer increment type ( MAJOR , MINOR , PATCH ) bump_pattern str None (OPTIONAL) Regex to extract information from commit (subject and body) Detailed question content Parameter Type Default Description type str None The type of questions. Valid type: list , input and etc. See More name str None The key for the value answered by user. It's used in message_template message str None Detail description for the question. choices list None (OPTIONAL) The choices when type = choice . It should be list of dictionaries with name and value . (e.g., [{value = \"feature\", name = \"feature: A new feature.\"}, {value = \"bug fix\", name = \"bug fix: A bug fix.\"}] ) default Any None (OPTIONAL) The default value for this question. filter str None (Optional) Validator for user's answer. (Work in Progress)","title":"Customization"},{"location":"customization/#customize-through-customize-class","text":"The basic steps are: Inheriting from BaseCommitizen Give a name to your rules. expose the class at the end of your file assigning it to discover_this Create a python package starting with cz_ using setup.py , poetry , etc Check an example on how to configure BaseCommitizen .","title":"Customize through customize class"},{"location":"customization/#custom-commit-rules","text":"Create a file starting with cz_ for example cz_jira.py . This prefix is used to detect the plugin. Same method flask uses Inherit from BaseCommitizen and you must define questions and message . The others are optionals. from commitizen.cz.base import BaseCommitizen class JiraCz ( BaseCommitizen ): def questions ( self ) -> list : \"\"\"Questions regarding the commit message.\"\"\" questions = [ { 'type' : 'input' , 'name' : 'title' , 'message' : 'Commit title' }, { 'type' : 'input' , 'name' : 'issue' , 'message' : 'Jira Issue number:' }, ] return questions def message ( self , answers : dict ) -> str : \"\"\"Generate the message with the given answers.\"\"\" return '{0} (#{1})' . format ( answers [ 'title' ], answers [ 'issue' ]) def example ( self ) -> str : \"\"\"Provide an example to help understand the style (OPTIONAL) Used by `cz example`. \"\"\" return 'Problem with user (#321)' def schema ( self ) -> str : \"\"\"Show the schema used (OPTIONAL) Used by `cz schema`. \"\"\" return '<title> (<issue>)' def info ( self ) -> str : \"\"\"Explanation of the commit rules. (OPTIONAL) Used by `cz info`. \"\"\" return 'We use this because is useful' discover_this = JiraCz # used by the plugin system The next file required is setup.py modified from flask version from setuptools import setup setup ( name = 'JiraCommitizen' , version = '0.1.0' , py_modules = [ 'cz_jira' ], license = 'MIT' , long_description = 'this is a long description' , install_requires = [ 'commitizen' ] ) So at the end we would have . \u251c\u2500\u2500 cz_jira.py \u2514\u2500\u2500 setup.py And that's it, you can install it without uploading to pypi by simply doing pip install . If you feel like it should be part of this repo, create a PR.","title":"Custom commit rules"},{"location":"customization/#custom-bump-rules","text":"You need to define 2 parameters inside BaseCommitizen . Parameter Type Default Description bump_pattern str None Regex to extract information from commit (subject and body) bump_map dict None Dictionary mapping the extracted information to a SemVer increment type ( MAJOR , MINOR , PATCH ) Let's see an exampple from commitizen.cz.base import BaseCommitizen class StrangeCommitizen ( BaseCommitizen ): bump_pattern = r \"^(break|new|fix|hotfix)\" bump_map = { \"break\" : \"MAJOR\" , \"new\" : \"MINOR\" , \"fix\" : \"PATCH\" , \"hotfix\" : \"PATCH\" } That's it, your commitizen now supports custom rules and you can run cz -n cz_strange bump","title":"Custom bump rules"},{"location":"customization/#raise-customize-exception","text":"If you wannt commitizen to catch your exception and print the message, you'll have to inherit CzException . from commitizen.cz.exception import CzException class NoSubjectProvidedException ( CzException ): ...","title":"Raise Customize Exception"},{"location":"customization/#customize-in-toml","text":"This is only supported when configuring through toml (e.g., pyproject.toml , .cz , and .cz.toml ) The basic steps are: 1. Define your custom committing or bumpping rules in the configuration file. 2. Declare name = \"cz_customize\" in your configuration file, or add -n cz_customize when running commitizen. Example: [tool.commitizen] name = \"cz_customize\" [tool.commitizen.customize] message_template = \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" example = \"feature: this feature eanable customize through config file\" schema = \"<type>: <body>\" bump_pattern = \"^(break|new|fix|hotfix)\" bump_map = {\"break\" = \"MAJOR\", \"new\" = \"MINOR\", \"fix\" = \"PATCH\", \"hotfix\" = \"PATCH\"} info_path = \"cz_customize_info.txt\" info = \"\"\" This is customized info \"\"\" [[tool.commitizen.customize.questions]] type = \"list\" name = \"change_type\" choices = [\"feature\", \"bug fix\"] message = \"Select the type of change you are committing\" [[tool.commitizen.customize.questions]] type = \"input\" name = \"message\" message = \"Body.\" [[tool.commitizen.customize.questions]] type = \"confirm\" name = \"show_message\" message = \"Do you want to add body message in commit?\"","title":"Customize in toml"},{"location":"customization/#customize-configuration","text":"Parameter Type Default Description question dict None Questions regarding the commit message. Detatiled below. message_template str None The template for generating message from the given answers. message_template should either follow the string.Template or Jinja2 formatting specification, and all the variables in this template should be defined in name in questions . Note that Jinja2 is not installed by default. If not installed, commitizen will use string.Template formatting. example str None (OPTIONAL) Provide an example to help understand the style. Used by cz example . schema str None (OPTIONAL) Show the schema used. Used by cz schema . info_path str None (OPTIONAL) The path to the file that contains explanation of the commit rules. Used by cz info . If not provided cz info , will load info instead. info str None (OPTIONAL) Explanation of the commit rules. Used by cz info . bump_map dict None (OPTIONAL) Dictionary mapping the extracted information to a SemVer increment type ( MAJOR , MINOR , PATCH ) bump_pattern str None (OPTIONAL) Regex to extract information from commit (subject and body)","title":"Customize configuration"},{"location":"customization/#detailed-question-content","text":"Parameter Type Default Description type str None The type of questions. Valid type: list , input and etc. See More name str None The key for the value answered by user. It's used in message_template message str None Detail description for the question. choices list None (OPTIONAL) The choices when type = choice . It should be list of dictionaries with name and value . (e.g., [{value = \"feature\", name = \"feature: A new feature.\"}, {value = \"bug fix\", name = \"bug fix: A bug fix.\"}] ) default Any None (OPTIONAL) The default value for this question. filter str None (Optional) Validator for user's answer. (Work in Progress)","title":"Detailed question content"},{"location":"tutorials/github_actions/","text":"Create new release with Github Actions Automatic bumping of version In order to execute cz bump in your CI, and push the new commit and the new tag, back to your master branch, we have to: 1. Create a personal access token. Follow the instructions here . And copy the generated key 2. Create a secret called PERSONAL_ACCESS_TOKEN , with the copied key, by going to your project repository and then Settings > Secrets > Add new secret . 3. In your repostiroy create a new file .github/workflows/bumpversion.yml with the following content. name : Bump version on : push : branches : - master # another branch could be specified here jobs : build : if : \"!contains(github.event.head_commit.message, 'bump')\" runs-on : ubuntu-latest strategy : matrix : python-version : [ '3.x' ] steps : - uses : actions/checkout@master - name : Set up Python ${{ matrix.python-version }} uses : actions/setup-python@v1 with : python-version : ${{ matrix.python-version }} - name : Install dependencies run : | python --version python --version python -m pip install -U commitizen - name : Create bump run : | git config --local user.email \"action@github.com\" git config --local user.name \"GitHub Action\" git config --local push.followTags true cz bump --yes git tag - name : Push changes uses : Woile/github-push-action@master with : github_token : ${{ secrets.PERSONAL_ACCESS_TOKEN }} tags : \"true\" Push to master and that's it. Publishing a python package Once the new tag is created, triggering an automatic publish command would be desired. In order to do so, first 2 secrets need to be added with the information of our pypi account. Go to Settings > Secrets > Add new secret and add the secrets: PYPI_USERNAME and PYPI_PASSWORD . Create a file in .github/workflows/pythonpublish.yaml with the following content: name : Upload Python Package on : push : tags : - '*' # Will trigger for every tag, alternative: 'v*' jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v1 - name : Set up Python uses : actions/setup-python@v1 with : python-version : '3.x' - name : Install dependencies run : | python -m pip install --pre -U poetry poetry --version poetry install - name : Build and publish env : PYPI_USERNAME : ${{ secrets.PYPI_USERNAME }} PYPI_PASSWORD : ${{ secrets.PYPI_PASSWORD }} run : | ./scripts/publish Notice that we are calling a bash script in ./scripts/publish , you should configure it with your tools (twine, poetry, etc). Check commitizen example Push the changes and that's it.","title":"Github Actions"},{"location":"tutorials/github_actions/#create-new-release-with-github-actions","text":"","title":"Create new release with Github Actions"},{"location":"tutorials/github_actions/#automatic-bumping-of-version","text":"In order to execute cz bump in your CI, and push the new commit and the new tag, back to your master branch, we have to: 1. Create a personal access token. Follow the instructions here . And copy the generated key 2. Create a secret called PERSONAL_ACCESS_TOKEN , with the copied key, by going to your project repository and then Settings > Secrets > Add new secret . 3. In your repostiroy create a new file .github/workflows/bumpversion.yml with the following content. name : Bump version on : push : branches : - master # another branch could be specified here jobs : build : if : \"!contains(github.event.head_commit.message, 'bump')\" runs-on : ubuntu-latest strategy : matrix : python-version : [ '3.x' ] steps : - uses : actions/checkout@master - name : Set up Python ${{ matrix.python-version }} uses : actions/setup-python@v1 with : python-version : ${{ matrix.python-version }} - name : Install dependencies run : | python --version python --version python -m pip install -U commitizen - name : Create bump run : | git config --local user.email \"action@github.com\" git config --local user.name \"GitHub Action\" git config --local push.followTags true cz bump --yes git tag - name : Push changes uses : Woile/github-push-action@master with : github_token : ${{ secrets.PERSONAL_ACCESS_TOKEN }} tags : \"true\" Push to master and that's it.","title":"Automatic bumping of version"},{"location":"tutorials/github_actions/#publishing-a-python-package","text":"Once the new tag is created, triggering an automatic publish command would be desired. In order to do so, first 2 secrets need to be added with the information of our pypi account. Go to Settings > Secrets > Add new secret and add the secrets: PYPI_USERNAME and PYPI_PASSWORD . Create a file in .github/workflows/pythonpublish.yaml with the following content: name : Upload Python Package on : push : tags : - '*' # Will trigger for every tag, alternative: 'v*' jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v1 - name : Set up Python uses : actions/setup-python@v1 with : python-version : '3.x' - name : Install dependencies run : | python -m pip install --pre -U poetry poetry --version poetry install - name : Build and publish env : PYPI_USERNAME : ${{ secrets.PYPI_USERNAME }} PYPI_PASSWORD : ${{ secrets.PYPI_PASSWORD }} run : | ./scripts/publish Notice that we are calling a bash script in ./scripts/publish , you should configure it with your tools (twine, poetry, etc). Check commitizen example Push the changes and that's it.","title":"Publishing a python package"},{"location":"tutorials/gitlab_ci/","text":"Create a new release usign GitLab CI For this example, we have a python/django application and Docker as containerization tool. Goal : Bump a new version every time that a change occurs on master branch. The bump should be executed automatically by the CI process. Development Workflow: A developer creates a new commit on any branch (except master ) A developer creates a merge request (MR) against master branch When the MR is merged into master, the 2 stages of the CI are executed For simplification, we store the software version in a file called VERSION . You can use any file that you want as commitizen supports it. The commit message executed automatically by the CI must include [skip-ci] in the message, otherwise the process will generate a loop. You can define the message structure in commitizen as well. Gitlab Configuration: In order to be able to change files and push new changes with Gitlab CI runners, we need to have a ssh key and configure a git user. First, let's create a ssh key . The only requirement is to create it without a passphrase: ssh-keygen -f deploy_key -N \"\" The previous command will create a private and public key under the files deploy_key and deploy_key.pub . We will use them later. For the git user, we need an email and username. You can choose whatever you want, in this example, we choose ci-runner@myproject.com and admin respectively. Now, we need to create three environment variables that will be visible for the runners. They should be created in the variables section under settings/ci_cd : Create SSH_PRIVATE_KEY , CI_EMAIL , CI_USERNAME variables and fill them with the private_key , email and username that we have created previously. The latest step is to create a deploy key. To do this, we should create it under the section settings/repository and fill it with the public key generated before. Check Write access allowed , otherwise, the runner won't be able to write the changes to the repository. If you have more projects under the same organization, you can reuse the deploy key created before, but you will have to repeat the step where we have created the environment variables (ssh key, email, and username). tip: If the CI raise some errors, try to unprotect the private key. Defining GitLab CI Pipeline Create a .gitlab-ci.yaml file that contains stages and jobs configurations. You can find more info here . Define stages and jobs . For this example, we define two stages with one job each one. Test the application. Auto bump the version. Means changing the file/s that reflects the version, creating a new commit and git tag. Stages and Jobs image : docker:latest services : - docker:dind variables : API_IMAGE_NAME : $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME before_script : - apk add --no-cache py-pip - pip install docker-compose stages : - test - auto-bump test : stage : test script : - docker-compose run -e DJANGO_ENVIRONMENT=dev your_project python manage.py test # run tests auto-bump : stage : auto-bump image : python:3.6 before_script : - 'which ssh-agent || ( apt-get update -qy && apt-get install openssh-client -qqy )' - eval `ssh-agent -s` - echo \"${SSH_PRIVATE_KEY}\" | tr -d '\\r' | ssh-add - > /dev/null # add ssh key - pip3 install -U Commitizen # install commitizen - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"$SSH_PUBLIC_KEY\" >> ~/.ssh/id_rsa.pub - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config' dependencies : - test script : - git remote set-url origin git@gitlab.com:discover/rentee-core.git # git configuration - git config --global user.email \"${CI_EMAIL}\" && git config --global user.name \"${CI_USERNAME}\" - 'exists=`git show-ref refs/heads/master` && if [ -n \"$exists\" ]; then git branch -D master; fi' - git checkout -b master - cz bump # execute auto bump and push to master - git push origin master:$CI_COMMIT_REF_NAME - TAG=$(head -n 1 VERSION) # get the new software version and save into artifacts - echo \"#!/bin/sh\" >> variables - echo \"export TAG='$TAG'\" >> variables - git push origin $TAG only : refs : - master artifacts : paths : - variables So, every time that a developer push to any branch the test job is executed. If the branch is master and the test jobs success, the auto-bump takes place. To be able to push using the Gitlab runner we have to set the ssh key, configure git and finally execute the auto bump. After merging the new changed into master we have the final result:","title":"GitLab CI"},{"location":"tutorials/gitlab_ci/#create-a-new-release-usign-gitlab-ci","text":"For this example, we have a python/django application and Docker as containerization tool. Goal : Bump a new version every time that a change occurs on master branch. The bump should be executed automatically by the CI process.","title":"Create a new release usign GitLab CI"},{"location":"tutorials/gitlab_ci/#development-workflow","text":"A developer creates a new commit on any branch (except master ) A developer creates a merge request (MR) against master branch When the MR is merged into master, the 2 stages of the CI are executed For simplification, we store the software version in a file called VERSION . You can use any file that you want as commitizen supports it. The commit message executed automatically by the CI must include [skip-ci] in the message, otherwise the process will generate a loop. You can define the message structure in commitizen as well.","title":"Development Workflow:"},{"location":"tutorials/gitlab_ci/#gitlab-configuration","text":"In order to be able to change files and push new changes with Gitlab CI runners, we need to have a ssh key and configure a git user. First, let's create a ssh key . The only requirement is to create it without a passphrase: ssh-keygen -f deploy_key -N \"\" The previous command will create a private and public key under the files deploy_key and deploy_key.pub . We will use them later. For the git user, we need an email and username. You can choose whatever you want, in this example, we choose ci-runner@myproject.com and admin respectively. Now, we need to create three environment variables that will be visible for the runners. They should be created in the variables section under settings/ci_cd : Create SSH_PRIVATE_KEY , CI_EMAIL , CI_USERNAME variables and fill them with the private_key , email and username that we have created previously. The latest step is to create a deploy key. To do this, we should create it under the section settings/repository and fill it with the public key generated before. Check Write access allowed , otherwise, the runner won't be able to write the changes to the repository. If you have more projects under the same organization, you can reuse the deploy key created before, but you will have to repeat the step where we have created the environment variables (ssh key, email, and username). tip: If the CI raise some errors, try to unprotect the private key.","title":"Gitlab Configuration:"},{"location":"tutorials/gitlab_ci/#defining-gitlab-ci-pipeline","text":"Create a .gitlab-ci.yaml file that contains stages and jobs configurations. You can find more info here . Define stages and jobs . For this example, we define two stages with one job each one. Test the application. Auto bump the version. Means changing the file/s that reflects the version, creating a new commit and git tag.","title":"Defining GitLab CI Pipeline"},{"location":"tutorials/gitlab_ci/#stages-and-jobs","text":"image : docker:latest services : - docker:dind variables : API_IMAGE_NAME : $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME before_script : - apk add --no-cache py-pip - pip install docker-compose stages : - test - auto-bump test : stage : test script : - docker-compose run -e DJANGO_ENVIRONMENT=dev your_project python manage.py test # run tests auto-bump : stage : auto-bump image : python:3.6 before_script : - 'which ssh-agent || ( apt-get update -qy && apt-get install openssh-client -qqy )' - eval `ssh-agent -s` - echo \"${SSH_PRIVATE_KEY}\" | tr -d '\\r' | ssh-add - > /dev/null # add ssh key - pip3 install -U Commitizen # install commitizen - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"$SSH_PUBLIC_KEY\" >> ~/.ssh/id_rsa.pub - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config' dependencies : - test script : - git remote set-url origin git@gitlab.com:discover/rentee-core.git # git configuration - git config --global user.email \"${CI_EMAIL}\" && git config --global user.name \"${CI_USERNAME}\" - 'exists=`git show-ref refs/heads/master` && if [ -n \"$exists\" ]; then git branch -D master; fi' - git checkout -b master - cz bump # execute auto bump and push to master - git push origin master:$CI_COMMIT_REF_NAME - TAG=$(head -n 1 VERSION) # get the new software version and save into artifacts - echo \"#!/bin/sh\" >> variables - echo \"export TAG='$TAG'\" >> variables - git push origin $TAG only : refs : - master artifacts : paths : - variables So, every time that a developer push to any branch the test job is executed. If the branch is master and the test jobs success, the auto-bump takes place. To be able to push using the Gitlab runner we have to set the ssh key, configure git and finally execute the auto bump. After merging the new changed into master we have the final result:","title":"Stages and Jobs"},{"location":"tutorials/writing_commits/","text":"","title":"Writing commits"}]}