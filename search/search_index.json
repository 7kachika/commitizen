{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Commitizen is a tool designed for teams. Its main purpose is to define a standard way of commiting rules and communicating it (using the cli provided by commitizen). The reasoning behind it is that is easier to read, and enforces writing descriptive commits. Besides that, having a convetion on your commits, makes it possible to parse them and use them for something else, like generating automatically the version or a changelog. Commitizen features Command line utility to create commits with your rules. Defaults: Conventional commits Display information about your commit rules (commands: schema, example, info) Bump version automatically using semantic verisoning based on the commits. Read More Generate a changelog using Keep a changelog (Planned feature) Requirements Python 3.6+ Git 1.8.5.2 + Installation Global installation sudo pip3 install -U Commitizen Python project You can add it to your local project using one of these: pip install -U commitizen poetry add commitizen --dev Usage Commiting Run in your terminal cz commit or the shortcut cz c Help $ cz --help usage: cz [ -h ] [ --debug ] [ -n NAME ] [ --version ] { ls,commit,c,example,info,schema,bump } ... Commitizen is a cli tool to generate conventional commits. For more information about the topic go to https://conventionalcommits.org/ optional arguments: -h, --help show this help message and exit --debug use debug mode -n NAME, --name NAME use the given commitizen --version get the version of the installed commitizen commands: { ls,commit,c,example,info,schema,bump } ls show available commitizens commit ( c ) create new commit example show commit example info show information about the cz schema show commit schema bump bump semantic version based on the git log Contributing Feel free to create a PR. Clone the repo. Add your modifications Create a virtualenv Run ./scripts/test","title":"Introduction"},{"location":"#about","text":"Commitizen is a tool designed for teams. Its main purpose is to define a standard way of commiting rules and communicating it (using the cli provided by commitizen). The reasoning behind it is that is easier to read, and enforces writing descriptive commits. Besides that, having a convetion on your commits, makes it possible to parse them and use them for something else, like generating automatically the version or a changelog.","title":"About"},{"location":"#commitizen-features","text":"Command line utility to create commits with your rules. Defaults: Conventional commits Display information about your commit rules (commands: schema, example, info) Bump version automatically using semantic verisoning based on the commits. Read More Generate a changelog using Keep a changelog (Planned feature)","title":"Commitizen features"},{"location":"#requirements","text":"Python 3.6+ Git 1.8.5.2 +","title":"Requirements"},{"location":"#installation","text":"Global installation sudo pip3 install -U Commitizen","title":"Installation"},{"location":"#python-project","text":"You can add it to your local project using one of these: pip install -U commitizen poetry add commitizen --dev","title":"Python project"},{"location":"#usage","text":"","title":"Usage"},{"location":"#commiting","text":"Run in your terminal cz commit or the shortcut cz c","title":"Commiting"},{"location":"#help","text":"$ cz --help usage: cz [ -h ] [ --debug ] [ -n NAME ] [ --version ] { ls,commit,c,example,info,schema,bump } ... Commitizen is a cli tool to generate conventional commits. For more information about the topic go to https://conventionalcommits.org/ optional arguments: -h, --help show this help message and exit --debug use debug mode -n NAME, --name NAME use the given commitizen --version get the version of the installed commitizen commands: { ls,commit,c,example,info,schema,bump } ls show available commitizens commit ( c ) create new commit example show commit example info show information about the cz schema show commit schema bump bump semantic version based on the git log","title":"Help"},{"location":"#contributing","text":"Feel free to create a PR. Clone the repo. Add your modifications Create a virtualenv Run ./scripts/test","title":"Contributing"},{"location":"bump/","text":"About The version is bumped automatically based on the commits. The commits should follow the rules of the commiter in order to be parsed properly. It is possible to specify a prerelease (alpha, beta, release candidate) version. The version can also be manually bumped. The version format follows semantic versioning . This means MAJOR.MiNOR.PATCH Increment Description Conventional commit map MAJOR Breaking changes introduced BREAKING CHANGE MINOR New features feat PATCH Fixes fix + everything else Prereleases are supported following python's PEP 0440 The scheme of this format is [N!]N(.N)*[{a|b|rc}N][.postN][.devN] Some examples: 0.9.0 0.9.1 0.9.2 0.9.10 0.9.11 1.0.0a0 # alpha 1.0.0a1 1.0.0b0 # beta 1.0.0rc0 # release candidate 1.0.0rc1 1.0.0 1.0.1 1.1.0 2.0.0 2.0.1a post and dev releases are not supported yet. Usage $ cz bump --help usage: cz bump [ -h ] [ --dry-run ] [ --tag-format TAG_FORMAT ] [ --prerelease { alpha,beta,rc }] [ --increment { MAJOR,MINOR,PATCH }] optional arguments: -h, --help show this help message and exit --dry-run show output to stdout, no commit, no modified files --tag-format TAG_FORMAT format used to tag the commmit and read it, use it in existing projects, wrap around simple quotes. --prerelease { alpha,beta,rc } , -pr { alpha,beta,rc } choose type of prerelease --increment { MAJOR,MINOR,PATCH } manually specify the desired increment Configuration tag_format Used to read the format from the git tags, and also to generate the tags. Supports 2 types of formats, a simple and a more complex. cz bump --tag_format = \"v $version \" cz bump --tag_format = \"v $minor . $major . $path$prerelease \" In your pyproject.toml [commitizen] tag_format = \"v$minor.$major.$path$prerelease\" The variables must be preceded by a $ sign. Suppported variables: Variable Description $version full generated version $major MAJOR increment $minor MINOR increment $patch PATCH increment $prerelease Prerelase (alpha, beta, release candidate) files Used to identify the files which should be updated with the new version. In your pyproject.toml Commitizen will update it's configuration ( pyproject.toml , .cz ) when bumping. [commitizen] files = [ \"src/__version__.py\", \"setup.py\" ]","title":"Bump"},{"location":"bump/#about","text":"The version is bumped automatically based on the commits. The commits should follow the rules of the commiter in order to be parsed properly. It is possible to specify a prerelease (alpha, beta, release candidate) version. The version can also be manually bumped. The version format follows semantic versioning . This means MAJOR.MiNOR.PATCH Increment Description Conventional commit map MAJOR Breaking changes introduced BREAKING CHANGE MINOR New features feat PATCH Fixes fix + everything else Prereleases are supported following python's PEP 0440 The scheme of this format is [N!]N(.N)*[{a|b|rc}N][.postN][.devN] Some examples: 0.9.0 0.9.1 0.9.2 0.9.10 0.9.11 1.0.0a0 # alpha 1.0.0a1 1.0.0b0 # beta 1.0.0rc0 # release candidate 1.0.0rc1 1.0.0 1.0.1 1.1.0 2.0.0 2.0.1a post and dev releases are not supported yet.","title":"About"},{"location":"bump/#usage","text":"$ cz bump --help usage: cz bump [ -h ] [ --dry-run ] [ --tag-format TAG_FORMAT ] [ --prerelease { alpha,beta,rc }] [ --increment { MAJOR,MINOR,PATCH }] optional arguments: -h, --help show this help message and exit --dry-run show output to stdout, no commit, no modified files --tag-format TAG_FORMAT format used to tag the commmit and read it, use it in existing projects, wrap around simple quotes. --prerelease { alpha,beta,rc } , -pr { alpha,beta,rc } choose type of prerelease --increment { MAJOR,MINOR,PATCH } manually specify the desired increment","title":"Usage"},{"location":"bump/#configuration","text":"tag_format Used to read the format from the git tags, and also to generate the tags. Supports 2 types of formats, a simple and a more complex. cz bump --tag_format = \"v $version \" cz bump --tag_format = \"v $minor . $major . $path$prerelease \" In your pyproject.toml [commitizen] tag_format = \"v$minor.$major.$path$prerelease\" The variables must be preceded by a $ sign. Suppported variables: Variable Description $version full generated version $major MAJOR increment $minor MINOR increment $patch PATCH increment $prerelease Prerelase (alpha, beta, release candidate) files Used to identify the files which should be updated with the new version. In your pyproject.toml Commitizen will update it's configuration ( pyproject.toml , .cz ) when bumping. [commitizen] files = [ \"src/__version__.py\", \"setup.py\" ]","title":"Configuration"},{"location":"config/","text":"Configuration New! : Support for pyproject.toml Add an entry to pyproject.toml . [tool.commitizen] name = \"cz_conventional_commits\" version = \"0.1.0\" files = [ \"src/__version__.py\", \"pyproject.toml\" ] Also, you can create in your project folder a file called .cz , .cz.cfg or in your setup.cfg or if you want to configure the global default in your user's home folder a .cz file with the following information: [commitizen] name = cz_conventional_commits version = 0.1.0 files = [ \"src/__version__.py\", \"pyproject.toml\" ] The extra tab at the end ( ] ) is required. settings Variable Type Default Description name str \"cz_conventional_commits\" Name of the commiting rules to use version str None Current version. Example: \"0.1.2\" files list [ ] Files were the version needs to be updated tag_format str None Format for the git tag, useful for old projects, that use a convention like \"v1.2.1\" . See more","title":"Configuration"},{"location":"config/#configuration","text":"New! : Support for pyproject.toml Add an entry to pyproject.toml . [tool.commitizen] name = \"cz_conventional_commits\" version = \"0.1.0\" files = [ \"src/__version__.py\", \"pyproject.toml\" ] Also, you can create in your project folder a file called .cz , .cz.cfg or in your setup.cfg or if you want to configure the global default in your user's home folder a .cz file with the following information: [commitizen] name = cz_conventional_commits version = 0.1.0 files = [ \"src/__version__.py\", \"pyproject.toml\" ] The extra tab at the end ( ] ) is required.","title":"Configuration"},{"location":"config/#settings","text":"Variable Type Default Description name str \"cz_conventional_commits\" Name of the commiting rules to use version str None Current version. Example: \"0.1.2\" files list [ ] Files were the version needs to be updated tag_format str None Format for the git tag, useful for old projects, that use a convention like \"v1.2.1\" . See more","title":"settings"},{"location":"customization/","text":"Custom commit rules Create a file starting with cz_ for example cz_jira.py . This prefix is used to detect the plugin. Same method flask uses Inherit from BaseCommitizen and you must define questions and message . The others are optionals. from commitizen.cz.base import BaseCommitizen class JiraCz ( BaseCommitizen ): def questions ( self ) -> list : \"\"\"Questions regarding the commit message.\"\"\" questions = [ { 'type' : 'input' , 'name' : 'title' , 'message' : 'Commit title' }, { 'type' : 'input' , 'name' : 'issue' , 'message' : 'Jira Issue number:' }, ] return questions def message ( self , answers : dict ) -> str : \"\"\"Generate the message with the given answers.\"\"\" return '{0} (#{1})' . format ( answers [ 'title' ], answers [ 'issue' ]) def example ( self ) -> str : \"\"\"Provide an example to help understand the style (OPTIONAL) Used by `cz example`. \"\"\" return 'Problem with user (#321)' def schema ( self ) -> str : \"\"\"Show the schema used (OPTIONAL) Used by `cz schema`. \"\"\" return '<title> (<issue>)' def info ( self ) -> str : \"\"\"Explanation of the commit rules. (OPTIONAL) Used by `cz info`. \"\"\" return 'We use this because is useful' discover_this = JiraCz # used by the plugin system The next file required is setup.py modified from flask version from setuptools import setup setup ( name = 'JiraCommitizen' , version = '0.1.0' , py_modules = [ 'cz_jira' ], license = 'MIT' , long_description = 'this is a long description' , install_requires = [ 'commitizen' ] ) So at the end we would have . \u251c\u2500\u2500 cz_jira.py \u2514\u2500\u2500 setup.py And that's it, you can install it without uploading to pypi by simply doing pip install . If you feel like it should be part of this repo, create a PR.","title":"Customization"},{"location":"customization/#custom-commit-rules","text":"Create a file starting with cz_ for example cz_jira.py . This prefix is used to detect the plugin. Same method flask uses Inherit from BaseCommitizen and you must define questions and message . The others are optionals. from commitizen.cz.base import BaseCommitizen class JiraCz ( BaseCommitizen ): def questions ( self ) -> list : \"\"\"Questions regarding the commit message.\"\"\" questions = [ { 'type' : 'input' , 'name' : 'title' , 'message' : 'Commit title' }, { 'type' : 'input' , 'name' : 'issue' , 'message' : 'Jira Issue number:' }, ] return questions def message ( self , answers : dict ) -> str : \"\"\"Generate the message with the given answers.\"\"\" return '{0} (#{1})' . format ( answers [ 'title' ], answers [ 'issue' ]) def example ( self ) -> str : \"\"\"Provide an example to help understand the style (OPTIONAL) Used by `cz example`. \"\"\" return 'Problem with user (#321)' def schema ( self ) -> str : \"\"\"Show the schema used (OPTIONAL) Used by `cz schema`. \"\"\" return '<title> (<issue>)' def info ( self ) -> str : \"\"\"Explanation of the commit rules. (OPTIONAL) Used by `cz info`. \"\"\" return 'We use this because is useful' discover_this = JiraCz # used by the plugin system The next file required is setup.py modified from flask version from setuptools import setup setup ( name = 'JiraCommitizen' , version = '0.1.0' , py_modules = [ 'cz_jira' ], license = 'MIT' , long_description = 'this is a long description' , install_requires = [ 'commitizen' ] ) So at the end we would have . \u251c\u2500\u2500 cz_jira.py \u2514\u2500\u2500 setup.py And that's it, you can install it without uploading to pypi by simply doing pip install . If you feel like it should be part of this repo, create a PR.","title":"Custom commit rules"}]}